import { fileFromSync } from 'fetch-blob/from.js';
import { FormData } from 'formdata-polyfill/esm.min.js';
import { z } from 'zod';
import isIP from 'validator/lib/isIP.js';
import isIPRange from 'validator/lib/isIPRange.js';
import isISO31661Alpha2 from 'validator/lib/isISO31661Alpha2.js';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

/**
 * I'm patching the type definitions for isISO31661Alpha2 because
 * it is returning some encapsulated object.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const _isISO31661Alpha2 = isISO31661Alpha2
    .default;
/**
 * Predicate function that verifies if a given array contains only valid ISO 3166-1 Alpha 2 countries.
 * @param arr Array of ISO 3166-1 Alpha 2 countries as string.
 * @returns Boolean if elements of the given array are valid.
 * @group Helpers
 */
const isArrISO31661Alpha2 = (arr) => arr
    .map(el => _isISO31661Alpha2(el))
    .reduce((acc, curr) => {
    if (curr) {
        acc = true;
    }
    return acc;
}, false);

/**
 * Removes a boolean query string parameter when its value is set to `false`.
 * Currently, the AbuseIPDB's API treats boolean query strings as `true` regardless of its value,
 * this function filter those values in order to return the right response.
 * The `Check` and `Blacklist` as text endpoints have such booleans.
 */
const filterBooleanAPIQueryStrings = (schema, parameter) => {
    const newSchema = { ...schema };
    if (schema[parameter] === false) {
        delete newSchema[parameter];
    }
    return newSchema;
};
const abuseIPDBClientRequiredSchema = z.object({
    /** Client API Key, must be generated at AbuseIPDB's client dashboard. */
    apiKey: z.string().min(1),
});
const abuseIPDBClientOptionsSchema = z.object({
    /**
     * Overrides the default AbuseIPDB base API url, can be used to proxy client requests.
     * @defaultValue `https://api.abuseipdb.com/api/v2`
     */
    url: z.string().optional(),
});
/**
 * @group Input - Validator
 */
const abuseIPDBClientSchema = abuseIPDBClientRequiredSchema.merge(abuseIPDBClientOptionsSchema);
z.object({
    /** Client API Key. */
    apiKey: z.string(),
    /**
     * Base API URL.
     * @defaultValue `https://api.abuseipdb.com/api/v2`
     */
    url: z.string(),
});
const checkRequiredSchema = z.object({
    /** Single IPv4/IPv6 address. */
    ipAddress: z
        .string()
        .refine(isIP, { message: 'Must be a valid IPv4/IPv6 Address' }),
});
const checkOptionsSchema = z.object({
    /** Show latest reports based on `n` days. Accepted values between 1 and 365, defaults to `30` by the API. */
    maxAgeInDays: z.number().int().min(1).max(365).optional(),
    /** Includes in the client response all the reports (Limited to 10,000) and country name entries, based on the `maxAgeInDays` parameter. Defaults to `false` by the API. */
    verbose: z.boolean().optional(),
});
/**
 * @group Input - Validator
 */
const checkSchema = checkRequiredSchema
    .merge(checkOptionsSchema)
    .transform(schema => filterBooleanAPIQueryStrings(schema, 'verbose'));
const reportsRequiredSchema = z.object({
    /** Single IPv4/IPv6 address. */
    ipAddress: z
        .string()
        .refine(isIP, { message: 'Must be a valid IPv4/IPv6 Address' }),
});
const reportsOptionsSchema = z.object({
    /** Show latest reports based on `n` days. Accepted values between 1 and 365, defaults to `30` by the API. */
    maxAgeInDays: z.number().int().min(1).max(365).optional(),
    /** Pagination number based on the `perPage` parameter. Minimum accepted value is 1, defaults to `1` by the API. */
    page: z.number().int().min(1).optional(),
    /** Amount of reports per page. Accepted values between 1 and 100, defaults to `25` by the API. */
    perPage: z.number().int().min(1).max(100).optional(),
});
/**
 * @group Input - Validator
 */
const reportsSchema = reportsRequiredSchema.merge(reportsOptionsSchema);
const blacklistOptionsSchema = z.object({
    /** Minimum confidence percentage value. Accepted values between 25 and 100, defaults to `100` by the API. Requires a subscription to use this feature.   */
    confidenceMinimum: z.number().int().min(25).max(100).optional(),
    /**
     * Limits the amount of returned reports. Accepted values between 1 and 500000, defaults to `10000` by the API.
     * The value is capped by your current subscription tier. (10k Standard, 100k Basic, 500k Premium).
     */
    limit: z.number().int().min(1).max(500000).optional(),
    /** Returns the response as a text list, instead of JSON structure. Result is wrapped in a `ClientResponse` */
    plaintext: z.boolean().optional(),
    /**
     * Filters the reports based on a given array of ISO 3166-1 Alpha-2 countries, including only the given list.
     * Requires a subscription to use this feature.
     * `onlyCountries` and `exceptCountries` are mutually exclusive, only one can be defined at a time. */
    onlyCountries: z.array(z.string()).optional(),
    /**
     * Filters the reports based on a given array of ISO 3166-1 Alpha-2 countries, excluding only the given list.
     * Requires a subscription to use this feature.
     * `onlyCountries` and `exceptCountries` are mutually exclusive, only one can be defined at a time. */
    exceptCountries: z.array(z.string()).optional(),
});
/**
 * @group Input - Validator
 */
const blacklistSchema = blacklistOptionsSchema
    .transform(schema => filterBooleanAPIQueryStrings(schema, 'plaintext'))
    .superRefine((schemaValues, ctx) => {
    // Countries declaration are optional, skip validation if this is the case.
    if (!(schemaValues.onlyCountries ?? schemaValues.exceptCountries)) {
        return;
    }
    if (schemaValues.onlyCountries && schemaValues.exceptCountries) {
        ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: '`exceptCountries` and `onlyCountries` are mutually exclusive, only one can be defined at a time.',
        });
        return;
    }
    const countriesParams = ['onlyCountries', 'exceptCountries'];
    for (const countryParam of countriesParams) {
        const countriesArr = schemaValues[countryParam];
        if (!countriesArr) {
            continue;
        }
        if (countriesArr.length === 0) {
            ctx.addIssue({
                code: z.ZodIssueCode.too_small,
                minimum: 1,
                type: 'array',
                inclusive: true,
                message: `[${countryParam}] Atleast one country must be specified.`,
            });
            continue;
        }
        if (!isArrISO31661Alpha2(countriesArr)) {
            ctx.addIssue({
                code: z.ZodIssueCode.custom,
                message: `[${countryParam}] Countries must be valid ISO 3166-1 Alpha-2 codes.`,
            });
        }
    }
});
const reportRequiredSchema = z.object({
    /** Single IPv4/IPv6 address. */
    ip: z.string().refine(isIP, { message: 'Must be a valid IPv4/IPv6 Address' }),
    /** Array of categories */
    categories: z.array(z.number().int().min(1).max(23)).min(1).max(30),
});
const reportOptionsSchema = z.object({
    /** Message to be added to the report, limited to 1024 characters. */
    comment: z.string().max(1024).optional(),
});
/**
 * @group Input - Validator
 */
const reportSchema = reportRequiredSchema.merge(reportOptionsSchema);
const checkBlockRequiredSchema = z.object({
    /**
     * Single IPv4/IPv6 address block in CIDR format.
     * The value is capped by your current subscription tier. (Up to /24 on Standard, /20 on Basic, /16 on Premium).
     */
    network: z
        .string()
        .refine(isIPRange, { message: 'Must be a valid CIDR block' }),
});
const checkBlockOptionsSchema = z.object({
    /**
     * Show latest reports based on `n` days. Accepted values between 1 and 365, defaults to `30` by the API.
     * The value is capped by your current subscription tier. (Up to 30 on Standard, 60 on Basic, 365 on Premium).
     */
    maxAgeInDays: z.number().int().min(1).max(365).optional(),
});
/**
 * @group Input - Validator
 */
const checkBlockSchema = checkBlockRequiredSchema.merge(checkBlockOptionsSchema);
const bulkReportRequiredSchema = z.object({
    /** Report CSV filepath to be sent. */
    csv: z.string(),
});
/**
 * @group Input - Validator
 */
const bulkReportSchema = bulkReportRequiredSchema;
/** Single IPv4/IPv6 address. */
const clearAddressRequiredSchema = z
    .string()
    .refine(isIP, { message: 'Must be a valid IPv4/IPv6 Address' });
/**
 * @group Input - Validator
 */
const clearAddressSchema = z.object({ ipAddress: clearAddressRequiredSchema });

/**
 * Base URL used to make client calls, defaults to AbuseIPDB's APIv2 Endpoint.
 * Can be changed when instatiating a new AbuseIPDBClient through the URL param.
 * @see {@link AbuseIPDBClientOptions}
 * @group Constants
 */
const BASE_URL = 'https://api.abuseipdb.com/api/v2';

var _AbuseIPDBClient_instances, _AbuseIPDBClient_headers, _AbuseIPDBClient_apiKey, _AbuseIPDBClient_url, _AbuseIPDBClient_setHeaders, _AbuseIPDBClient_buildResponseHeaders, _AbuseIPDBClient_formatResponse, _AbuseIPDBClient_requestData, _AbuseIPDBClient_formatRequestBulkReport, _AbuseIPDBClient_formatUrl, _AbuseIPDBClient_validateData, _AbuseIPDBClient_handleRequest;
const ENDPOINTS = {
    check: {
        method: 'GET',
        schema: checkSchema,
    },
    reports: {
        method: 'GET',
        schema: reportsSchema,
    },
    blacklist: {
        method: 'GET',
        schema: blacklistSchema,
    },
    report: {
        method: 'POST',
        schema: reportSchema,
    },
    'check-block': {
        method: 'GET',
        schema: checkBlockSchema,
    },
    'bulk-report': {
        method: 'POST',
        schema: bulkReportSchema,
    },
    'clear-address': {
        method: 'DELETE',
        schema: clearAddressSchema,
    },
};
/**
 * @group Client
 */
class AbuseIPDBClient {
    /**
     * Creates a new AbuseIPDB client, requires an API key from AbuseIPDB's dashboard.
     * @param apiKey AbuseIPDB client API key.
     * @param options Optional parameters - {@link AbuseIPDBClientOptions}
     */
    constructor(apiKey, options) {
        _AbuseIPDBClient_instances.add(this);
        _AbuseIPDBClient_headers.set(this, void 0);
        _AbuseIPDBClient_apiKey.set(this, void 0);
        _AbuseIPDBClient_url.set(this, void 0);
        const params = { apiKey, ...options };
        const validatedParams = __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_validateData).call(this, params, abuseIPDBClientSchema);
        __classPrivateFieldSet(this, _AbuseIPDBClient_apiKey, validatedParams.apiKey, "f");
        __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_setHeaders).call(this, validatedParams.apiKey);
        if (validatedParams?.url) {
            __classPrivateFieldSet(this, _AbuseIPDBClient_url, validatedParams.url, "f");
            return;
        }
        __classPrivateFieldSet(this, _AbuseIPDBClient_url, BASE_URL, "f");
    }
    /**
     * Returns the current client config.
     */
    getConfig() {
        return {
            apiKey: __classPrivateFieldGet(this, _AbuseIPDBClient_apiKey, "f"),
            url: __classPrivateFieldGet(this, _AbuseIPDBClient_url, "f"),
        };
    }
    /**
     * @see [Check API Endpoint](https://docs.abuseipdb.com/#check-endpoint)
     * @param ipAddress Single IPv4/IPv6 address to be verified.
     * @param options Optional parameters - {@link CheckOptions}
     */
    async check(ipAddress, options) {
        return __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_handleRequest).call(this, 'check', {
            ipAddress,
            ...options,
        });
    }
    /**
     * @see [Reports API Endpoint](https://docs.abuseipdb.com/#reports-endpoint)
     * @param ipAddress Single IPv4/IPv6 address to be verified.
     * @param options Optional parameters - {@link ReportsOptions}
     * @beta
     */
    async reports(ipAddress, options) {
        return __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_handleRequest).call(this, 'reports', { ipAddress, ...options });
    }
    /**
     * @see [Blacklist API Endpoint](https://docs.abuseipdb.com/#blacklist-endpoint)
     * @param options Optional parameters - {@link BlacklistOptions}
     */
    async blacklist(options) {
        return __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_handleRequest).call(this, 'blacklist', { ...options });
    }
    /**
     * @see [Report API Endpoint](https://docs.abuseipdb.com/#report-endpoint)
     * @param ip Single IPv4/IPv6 address to be verified.
     * @param categories Array of categories to be reported.
     * @param options Optional parameters - {@link ReportOptions}
     */
    async report(ip, categories, options) {
        return __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_handleRequest).call(this, 'report', { ip, categories, ...options });
    }
    /**
     * @see [Check-Block API Endpoint](https://docs.abuseipdb.com/#check-block-endpoint)
     * @param network Single IPv4/IPv6 address block in CIDR format.
     * @param options Optional parameters - {@link CheckBlockOptions}
     */
    async checkBlock(network, options) {
        return __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_handleRequest).call(this, 'check-block', { network, ...options });
    }
    /**
     * @see [Bulk-Report API Endpoint](https://docs.abuseipdb.com/#bulk-report-endpoint)
     * @param csv CSV filepath to be sent.
     */
    async bulkReport(csv) {
        return __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_handleRequest).call(this, 'bulk-report', { csv });
    }
    /**
     * @see [Clear-Address API Endpoint](https://docs.abuseipdb.com/#clear-address-endpoint)
     * @param ipAddress Single IPv4/IPv6 address.
     */
    async clearAddress(ipAddress) {
        return __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_handleRequest).call(this, 'clear-address', { ipAddress });
    }
}
_AbuseIPDBClient_headers = new WeakMap(), _AbuseIPDBClient_apiKey = new WeakMap(), _AbuseIPDBClient_url = new WeakMap(), _AbuseIPDBClient_instances = new WeakSet(), _AbuseIPDBClient_setHeaders = function _AbuseIPDBClient_setHeaders(apiKey) {
    __classPrivateFieldSet(this, _AbuseIPDBClient_headers, {
        Key: apiKey,
        Accept: 'application/json',
    }, "f");
}, _AbuseIPDBClient_buildResponseHeaders = function _AbuseIPDBClient_buildResponseHeaders(response) {
    const headersJson = {};
    // From fetch response.
    headersJson.url = response.url;
    headersJson.status = response.status;
    headersJson.statusText = response.statusText;
    // From AbuseIPDB API HTTP headers.
    const rateLimitKeys = [
        'retry-after',
        'x-ratelimit-limit',
        'x-ratelimit-remaining',
        'x-ratelimit-reset',
        'x-generated-at',
    ];
    for (const key of rateLimitKeys) {
        const value = response.headers.get(key);
        if (value) {
            headersJson[key] = value;
        }
    }
    return headersJson;
}, _AbuseIPDBClient_formatResponse = async function _AbuseIPDBClient_formatResponse(fetchAPIResponse) {
    const headers = __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_buildResponseHeaders).call(this, fetchAPIResponse);
    let formattedResponse;
    /**
     * The `x-generated-at` header is present on blacklist API text endpoint response, it
     * is formatted here to keep consistency.
     * @see {@link APIBlacklistEndpointTextResponse}
     */
    if (headers['x-generated-at']) {
        const xGeneratedAt = headers['x-generated-at'];
        delete headers['x-generated-at'];
        const bodyWithMeta = {
            meta: {
                generatedAt: xGeneratedAt,
            },
            data: await fetchAPIResponse.text(),
        };
        formattedResponse = {
            headers,
            result: bodyWithMeta,
        };
    }
    else {
        const body = await fetchAPIResponse.json();
        if (body.errors) {
            formattedResponse = { headers, error: body };
        }
        else {
            formattedResponse = {
                headers,
                result: body,
            };
        }
    }
    return formattedResponse;
}, _AbuseIPDBClient_requestData = async function _AbuseIPDBClient_requestData(url, method, headers, body) {
    return fetch(url, {
        method,
        headers,
        body,
    });
}, _AbuseIPDBClient_formatRequestBulkReport = function _AbuseIPDBClient_formatRequestBulkReport(headers, data) {
    const { csv } = data;
    const file = fileFromSync(csv);
    const formData = new FormData();
    formData.append('csv', file);
    return {
        headers,
        body: formData,
    };
}, _AbuseIPDBClient_formatUrl = function _AbuseIPDBClient_formatUrl(uri, params) {
    const url = new URL(`${__classPrivateFieldGet(this, _AbuseIPDBClient_url, "f")}/${uri}`);
    for (const key of Object.keys(params ?? {})) {
        url.searchParams.append(key, params?.[key]);
    }
    return url.href;
}, _AbuseIPDBClient_validateData = function _AbuseIPDBClient_validateData(parameters, schema) {
    const result = schema.safeParse(parameters);
    if (!result.success) {
        throw result.error;
    }
    else {
        return result.data;
    }
}, _AbuseIPDBClient_handleRequest = async function _AbuseIPDBClient_handleRequest(endpointURI, parameters) {
    const { method, schema } = ENDPOINTS[endpointURI];
    // Validates the input parameters given by the client.
    const validatedInput = __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_validateData).call(this, parameters, schema);
    let response;
    if (endpointURI === 'bulk-report') {
        // There is no need to append QueryParams for the bulk-report endpoint, so it is removed here.
        const url = __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_formatUrl).call(this, endpointURI);
        const { headers, body } = __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_formatRequestBulkReport).call(this, __classPrivateFieldGet(this, _AbuseIPDBClient_headers, "f"), parameters);
        response = await __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_requestData).call(this, url, method, headers, body);
    }
    else {
        const url = __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_formatUrl).call(this, endpointURI, validatedInput);
        response = await __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_requestData).call(this, url, method, __classPrivateFieldGet(this, _AbuseIPDBClient_headers, "f"));
    }
    // Transforms the API fetch response to the library format.
    const formattedResponseData = await __classPrivateFieldGet(this, _AbuseIPDBClient_instances, "m", _AbuseIPDBClient_formatResponse).call(this, response);
    return formattedResponseData;
};

/**
 * AbuseIPDB Report Category types.
 * @see [AbuseIPDB Report Categories](https://www.abuseipdb.com/categories)
 * @enum
 * @group AbuseIPDB API Response
 * @example
 * ```typescript
 * import { ReportCategory } from 'abuseipdb-client';
 *
 * // `ReportCategory` enum can be used to populate an array of categories.
 * const categories: Array<ReportCategory> = [
 *   ReportCategory.WebSpam,
 *   ReportCategory.BadWebBot,
 *   ReportCategory.BruteForce,
 * ];
 *
 * // Which translates to:
 * // categories = [ 10, 19, 18 ].
 *
 * // That way, it is possible to call the `report` endpoint using this reference directly:
 * client.report('127.0.0.1', categories);
 * ```
 */
var ReportCategory;
(function (ReportCategory) {
    /**
     * Altering DNS records resulting in improper redirection.
     */
    ReportCategory[ReportCategory["DNSCompromise"] = 1] = "DNSCompromise";
    /**
     * Falsifying domain server cache (cache poisoning).
     */
    ReportCategory[ReportCategory["DNSPoisoning"] = 2] = "DNSPoisoning";
    /**
     * Fraudulent orders.
     */
    ReportCategory[ReportCategory["FraudOrders"] = 3] = "FraudOrders";
    /**
     * Participating in distributed denial-of-service (usually part of botnet).
     */
    ReportCategory[ReportCategory["DDOSAttack"] = 4] = "DDOSAttack";
    /**
     * FTP Brute force attempt.
     */
    ReportCategory[ReportCategory["FTPBruteForce"] = 5] = "FTPBruteForce";
    /**
     * Oversized IP packet.
     */
    ReportCategory[ReportCategory["PingOfDeath"] = 6] = "PingOfDeath";
    /**
     * Phishing websites and/or email.
     */
    ReportCategory[ReportCategory["Phishing"] = 7] = "Phishing";
    /**
     * Voice-over-IP fraud.
     */
    ReportCategory[ReportCategory["FraudVoIP"] = 8] = "FraudVoIP";
    /**
     * Open proxy, open relay, or Tor exit node.
     */
    ReportCategory[ReportCategory["OpenProxy"] = 9] = "OpenProxy";
    /**
     * Comment/forum spam, HTTP referer spam, or other CMS spam.
     */
    ReportCategory[ReportCategory["WebSpam"] = 10] = "WebSpam";
    /**
     * Spam email content, infected attachments, and phishing emails. Note: Limit comments to only relevent information (instead of log dumps) and be sure to remove PII if you want to remain anonymous.
     */
    ReportCategory[ReportCategory["EmailSpam"] = 11] = "EmailSpam";
    /**
     * CMS blog comment spam.
     */
    ReportCategory[ReportCategory["BlogSpam"] = 12] = "BlogSpam";
    /**
     * VPN IP address.
     */
    ReportCategory[ReportCategory["VPNIP"] = 13] = "VPNIP";
    /**
     * Scanning for open ports and vulnerable services.
     */
    ReportCategory[ReportCategory["PortScan"] = 14] = "PortScan";
    /**
     * General hacking attempt.
     */
    ReportCategory[ReportCategory["Hacking"] = 15] = "Hacking";
    /**
     * Attempts at SQL injection.
     */
    ReportCategory[ReportCategory["SQLInjection"] = 16] = "SQLInjection";
    /**
     * Email sender spoofing.
     */
    ReportCategory[ReportCategory["Spoofing"] = 17] = "Spoofing";
    /**
     * Credential brute-force attacks on webpage logins and services like SSH, FTP, SIP, SMTP, RDP, etc. This category is seperate from DDoS attacks.
     */
    ReportCategory[ReportCategory["BruteForce"] = 18] = "BruteForce";
    /**
     * Webpage scraping (for email addresses, content, etc) and crawlers that do not honor robots.txt. Excessive requests and user agent spoofing can also be reported here.
     */
    ReportCategory[ReportCategory["BadWebBot"] = 19] = "BadWebBot";
    /**
     * Host is likely infected with malware and being used for other attacks or to host malicious content. The host owner may not be aware of the compromise. This category is often used in combination with other attack categories.
     */
    ReportCategory[ReportCategory["ExploitedHost"] = 20] = "ExploitedHost";
    /**
     * Attempts to probe for or exploit installed web applications such as a CMS like WordPress/Drupal, e-commerce solutions, forum software, phpMyAdmin and various other software plugins/solutions.
     */
    ReportCategory[ReportCategory["WebAppAttack"] = 21] = "WebAppAttack";
    /**
     * Secure Shell (SSH) abuse. Use this category in combination with more specific categories.
     */
    ReportCategory[ReportCategory["SSH"] = 22] = "SSH";
    /**
     * Abuse was targeted at an "Internet of Things" type device. Include information about what type of device was targeted in the comments.
     */
    ReportCategory[ReportCategory["IOTTargeted"] = 23] = "IOTTargeted";
})(ReportCategory || (ReportCategory = {}));

export { AbuseIPDBClient, BASE_URL, ReportCategory, abuseIPDBClientSchema, blacklistSchema, bulkReportSchema, checkBlockSchema, checkSchema, clearAddressSchema, isArrISO31661Alpha2, reportSchema, reportsSchema };
